#include <fstream>
#include <math.h>
#include <uWS/uWS.h>
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>
#include "Eigen-3.3/Eigen/Core"
#include "Eigen-3.3/Eigen/QR"
#include "json.hpp"
#include "spline.h"

using namespace std;

// for convenience
using json = nlohmann::json;

// For converting back and forth between radians and degrees.
constexpr double pi() { return M_PI; }
double deg2rad(double x) { return x * pi() / 180; }
double rad2deg(double x) { return x * 180 / pi(); }

// Checks if the SocketIO event has JSON data.
// If there is data the JSON object in string format will be returned,
// else the empty string "" will be returned.
string hasData(string s) {
    auto found_null = s.find("null");
    auto b1 = s.find_first_of("[");
    auto b2 = s.find_first_of("}");
    if (found_null != string::npos) {
        return "";
    } else if (b1 != string::npos && b2 != string::npos) {
        return s.substr(b1, b2 - b1 + 2);
    }
    return "";
}

double distance(double x1, double y1, double x2, double y2)
{
    return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}
int ClosestWaypoint(double x, double y, const vector<double> &maps_x, const vector<double> &maps_y)
{

    double closestLen = 100000; //large number
    int closestWaypoint = 0;

    for(int i = 0; i < maps_x.size(); i++)
    {
        double map_x = maps_x[i];
        double map_y = maps_y[i];
        double dist = distance(x,y,map_x,map_y);
        if(dist < closestLen)
        {
            closestLen = dist;
            closestWaypoint = i;
        }

    }

    return closestWaypoint;

}

int NextWaypoint(double x, double y, double theta, const vector<double> &maps_x, const vector<double> &maps_y)
{

    int closestWaypoint = ClosestWaypoint(x,y,maps_x,maps_y);

    double map_x = maps_x[closestWaypoint];
    double map_y = maps_y[closestWaypoint];

    double heading = atan2((map_y-y),(map_x-x));

    double angle = fabs(theta-heading);
    angle = min(2*pi() - angle, angle);

    if(angle > pi()/4)
    {
        closestWaypoint++;
        if (closestWaypoint == maps_x.size())
        {
            closestWaypoint = 0;
        }
    }

    return closestWaypoint;
}

// Transform from Cartesian x,y coordinates to Frenet s,d coordinates
vector<double> getFrenet(double x, double y, double theta, const vector<double> &maps_x, const vector<double> &maps_y)
{
    int next_wp = NextWaypoint(x,y, theta, maps_x,maps_y);

    int prev_wp;
    prev_wp = next_wp-1;
    if(next_wp == 0)
    {
        prev_wp  = maps_x.size()-1;
    }

    double n_x = maps_x[next_wp]-maps_x[prev_wp];
    double n_y = maps_y[next_wp]-maps_y[prev_wp];
    double x_x = x - maps_x[prev_wp];
    double x_y = y - maps_y[prev_wp];

    // find the projection of x onto n
    double proj_norm = (x_x*n_x+x_y*n_y)/(n_x*n_x+n_y*n_y);
    double proj_x = proj_norm*n_x;
    double proj_y = proj_norm*n_y;

    double frenet_d = distance(x_x,x_y,proj_x,proj_y);

    //see if d value is positive or negative by comparing it to a center point

    double center_x = 1000-maps_x[prev_wp];
    double center_y = 2000-maps_y[prev_wp];
    double centerToPos = distance(center_x,center_y,x_x,x_y);
    double centerToRef = distance(center_x,center_y,proj_x,proj_y);

    if(centerToPos <= centerToRef)
    {
        frenet_d *= -1;
    }

    // calculate s value
    double frenet_s = 0;
    for(int i = 0; i < prev_wp; i++)
    {
        frenet_s += distance(maps_x[i],maps_y[i],maps_x[i+1],maps_y[i+1]);
    }

    frenet_s += distance(0,0,proj_x,proj_y);

    return {frenet_s,frenet_d};

}

// Transform from Frenet s,d coordinates to Cartesian x,y
vector<double> getXY(double s, double d, const vector<double> &maps_s, const vector<double> &maps_x, const vector<double> &maps_y)
{
    int prev_wp = -1;

    while(s > maps_s[prev_wp+1] && (prev_wp < (int)(maps_s.size()-1) ))
    {
        prev_wp++;
    }

    int wp2 = (prev_wp+1)%maps_x.size();

    double heading = atan2((maps_y[wp2]-maps_y[prev_wp]),(maps_x[wp2]-maps_x[prev_wp]));
    // the x,y,s along the segment
    double seg_s = (s-maps_s[prev_wp]);

    double seg_x = maps_x[prev_wp]+seg_s*cos(heading);
    double seg_y = maps_y[prev_wp]+seg_s*sin(heading);

    double perp_heading = heading-pi()/2;

    double x = seg_x + d*cos(perp_heading);
    double y = seg_y + d*sin(perp_heading);

    return {x,y};

}

// define some other functions
double absolute(double x, double y)
{
    return sqrt(pow(x,2) + pow(y, 2));
}

double find_lane(double car_d)
{
    double lane_no;
    if ( (car_d>=0) && (car_d<4.0) )
    {
        lane_no = 1;
    } else if ( (car_d>=4.0) && (car_d<8.0) )
    {
        lane_no = 2;
    } else if ( (car_d>=8.0) && (car_d<12.0) )
    {
        lane_no = 3;
    } else
    {
        lane_no = 0;  // out of bound
    }
}

double mph2ms(double mph)
{
    return mph * (1600.0 / 3600.0);
}

double ms2mph(double ms)
{
    return ms * (3600.0 / 1600.0);
}

// define cost functions for keep lane, turn left/right/slow down
double cost_keep_lane(double num_cars_in_mylane, double dist_closest_front, double buffer_my, double cost_collision)
{
    double cost;
    if (num_cars_in_mylane == 0)
    {
        cost = 0;
    }else
    {
        if (dist_closest_front <= buffer_my)  // too close to car in front
        {
            cost = cost_collision;
        }else
        {
            cost = 0;
        }
    }
    return cost;
}

double cost_change_left(double dist_closest_left_front, double dist_closest_left_back,double buffer_lc, double cost_collision, double cost_left_turn, bool violate_left)
{
    double cost;
    if (violate_left)
    {
        cost = cost_collision;
    }else
    {
        if ((dist_closest_left_front>=2.5*buffer_lc) && (dist_closest_left_back>=0.6*buffer_lc))
        {
            if (dist_closest_left_front >=200)
            {
                cost = cost_left_turn*0.9;
            }else
            {
                cost = cost_left_turn;
            }
        }else
        {
            cost = cost_collision;
        }
    }

    return cost;
}


double cost_change_right(double dist_closest_right_front, double dist_closest_right_back,double buffer_lc, double cost_collision, double cost_right_turn, bool violate_right)
{
    double cost;
    if (violate_right)
    {
        cost = cost_collision;
    }else
    {
        if ((dist_closest_right_front>=2.5*buffer_lc) && (dist_closest_right_back>=0.6*buffer_lc))
        {
            if (dist_closest_right_front >=200)
            {
                cost = cost_right_turn*0.9;
            }else
            {
                cost = cost_right_turn;
            }
        }else
        {
            cost = cost_collision;
        }
    }

    return cost;
}

double cost_slow_down_inlane(double cost_slow_down)
{
    double cost;
    cost = cost_slow_down + 0.0;
    return cost;
}


// main function
int main() {
    uWS::Hub h;

    // Load up map values for waypoint's x,y,s and d normalized normal vectors
    vector<double> map_waypoints_x;
    vector<double> map_waypoints_y;
    vector<double> map_waypoints_s;
    vector<double> map_waypoints_dx;
    vector<double> map_waypoints_dy;

    // Waypoint map to read from
    string map_file_ = "../data/highway_map.csv";
    // The max s value before wrapping around the track back to 0
    double max_s = 6945.554;

    ifstream in_map_(map_file_.c_str(), ifstream::in);

    string line;
    while (getline(in_map_, line)) {
        istringstream iss(line);
        double x;
        double y;
        float s;
        float d_x;
        float d_y;
        iss >> x;
        iss >> y;
        iss >> s;
        iss >> d_x;
        iss >> d_y;
        map_waypoints_x.push_back(x);
        map_waypoints_y.push_back(y);
        map_waypoints_s.push_back(s);
        map_waypoints_dx.push_back(d_x);
        map_waypoints_dy.push_back(d_y);
    }

    // TODO -------------------------------------------


    // correct spline calculation at the end of track
    map_waypoints_x.push_back(map_waypoints_x[0]);
    map_waypoints_y.push_back(map_waypoints_y[0]);
    map_waypoints_s.push_back(max_s+map_waypoints_s[0]);
    map_waypoints_dx.push_back(map_waypoints_dx[0]);
    map_waypoints_dy.push_back(map_waypoints_dy[0]);

    map_waypoints_x.push_back(map_waypoints_x[1]);
    map_waypoints_y.push_back(map_waypoints_y[1]);
    map_waypoints_s.push_back(max_s+map_waypoints_s[1]);
    map_waypoints_dx.push_back(map_waypoints_dx[1]);
    map_waypoints_dy.push_back(map_waypoints_dy[1]);


    //Decided to fit splines relative to the s coordinate
    //Idea from slack channel


    tk::spline path_spline_x;
    path_spline_x.set_points(map_waypoints_s, map_waypoints_x);

    tk::spline path_spline_y;
    path_spline_y.set_points(map_waypoints_s, map_waypoints_y);


    tk::spline path_spline_dx;
    path_spline_dx.set_points(map_waypoints_s, map_waypoints_dx);

    tk::spline path_spline_dy;
    path_spline_dy.set_points(map_waypoints_s, map_waypoints_dy);


    // end of TODO----------------------------------------------


    h.onMessage([&map_waypoints_x,&map_waypoints_y,&map_waypoints_s,&map_waypoints_dx,&map_waypoints_dy,&max_s, &path_spline_x, &path_spline_y, &path_spline_dx, &path_spline_dy](uWS::WebSocket<uWS::SERVER> ws, char *data, size_t length,
                                                                                                                                                                                  uWS::OpCode opCode) {
        // "42" at the start of the message means there's a websocket message event.
        // The 4 signifies a websocket message
        // The 2 signifies a websocket event
        //auto sdata = string(data).substr(0, length);
        //cout << sdata << endl;
        if (length && length > 2 && data[0] == '4' && data[1] == '2') {

            auto s = hasData(data);

            if (s != "") {
                auto j = json::parse(s);

                string event = j[0].get<string>();

                if (event == "telemetry") {
                    // j[1] is the data JSON object

                    // Main car's localization Data
                    double car_x = j[1]["x"];
                    double car_y = j[1]["y"];
                    double car_s = j[1]["s"];
                    double car_d = j[1]["d"];
                    double car_yaw = j[1]["yaw"];
                    double car_speed = j[1]["speed"];

                    // Previous path data given to the Planner
                    auto previous_path_x = j[1]["previous_path_x"];
                    auto previous_path_y = j[1]["previous_path_y"];
                    // Previous path's end s and d values
                    double end_path_s = j[1]["end_path_s"];
                    double end_path_d = j[1]["end_path_d"];

                    // Sensor Fusion Data, a list of all other cars on the same side of the road.
//          	auto sensor_fusion = j[1]["sensor_fusion"];
                    vector<vector<double>> sensor_fusion = j[1]["sensor_fusion"];


                    //TODO: --------------------------------------------------

                    //start looking at sensor fusion data

                    // store other cars position and velocity
                    vector<double> cars_mylane_s;
                    vector<double> cars_myleft_s;
                    vector<double> cars_myright_s;

                    vector<double> cars_mylane_vel;
                    vector<double> cars_myleft_vel;
                    vector<double> cars_myright_vel;

                    double target_d;
                    double target_s_inc;

                    double dist_closest_front = 999;
                    double vel_closest_front = 0;

                    double dist_closest_left_front = 999;
                    double dist_closest_left_back = 999;
                    double vel_closest_left_front = 0;

                    double dist_closest_right_front = 999;
                    double dist_closest_right_back = 999;
                    double vel_closest_right_front = 0;

                    bool violate_left = false;
                    bool violate_right = false;

                    // STEP1 : find other cars' position and velocity in e lanes

                    for (int i = 0; i < sensor_fusion.size(); ++i) //iterate over all other cars' data
                    {
                        double other_id = sensor_fusion[i][0];
                        double other_x = sensor_fusion[i][1];
                        double other_y = sensor_fusion[i][2];
                        double other_vx = sensor_fusion[i][3];
                        double other_vy = sensor_fusion[i][4];
                        double other_s = sensor_fusion[i][5];
                        double other_d = sensor_fusion[i][6];
                        double other_vel = sqrt(pow(other_vx,2) + pow(other_vy,2));
                        double other_dist = distance(car_x, car_y, other_x, other_y);

                        if (find_lane(car_d) == find_lane(other_d)) // if other car is in my lane
                        {
                            cars_mylane_s.push_back(other_s);
                            cars_mylane_vel.push_back(other_vel);
                        }else if (find_lane(other_d) == find_lane(car_d)-1)
                        {
                            cars_myleft_s.push_back(other_s);
                            cars_myleft_vel.push_back(other_vel);
                        }else if (find_lane(other_d) == find_lane(car_d)+1)
                        {
                            cars_myright_s.push_back(other_s);
                            cars_myright_vel.push_back(other_vel);
                        }
                    }

                    // debug
//                    cout<< endl;
//                    cout<< "number of cars in my lane:" << cars_mylane_s.size()<<endl;
//                    cout<< "number of cars in my left:" << cars_myleft_s.size()<<endl;
//                    cout<< "number of cars in my right:" << cars_myright_s.size()<<endl;
//                    cout<< endl;

                    // find the closest car in my lane and in front of me
                    if (cars_mylane_s.size() > 0)
                    {
                        for (int i = 0; i < cars_mylane_s.size(); ++i)
                        {
                            double other_mylane_s = cars_mylane_s[i];
                            double dist2mycar = other_mylane_s - car_s;
                            if ((dist2mycar > 0) && (dist2mycar < abs(dist_closest_front)))
                            {
                                dist_closest_front = dist2mycar;
                                vel_closest_front = cars_mylane_vel[i];
                            }
                        }
                    }

                    //debug
//                    cout<<endl;
//                    cout<<"distance of closest car in front of me is:"<<dist_closest_front<<endl;
//                    cout<<endl;

                    //find the closest car in left lane
                    if (find_lane(car_d) > 1) // if there is any left lane
                    {
                        if (cars_myleft_s.size() == 0)
                        {
                            dist_closest_left_front = 999;
                            dist_closest_left_back = 999;
                            vel_closest_left_front = 0;
                        }else
                        {
                            for (int i = 0; i < cars_myleft_s.size(); ++i)
                            {
                                double other_myleft_s = cars_myleft_s[i];
                                double dist2mycar_left = other_myleft_s - car_s;
                                if (dist2mycar_left >= 0) // front left
                                {
                                    if (dist2mycar_left < abs(dist_closest_left_front))
                                    {
                                        dist_closest_left_front = dist2mycar_left;
                                        vel_closest_left_front = cars_myleft_vel[i];
                                    }
                                }else if (dist2mycar_left < 0) // back left
                                {
                                    if (abs(dist2mycar_left) < abs(dist_closest_left_back))
                                    {
                                        dist_closest_left_back = abs(dist2mycar_left);
                                    }
                                }


                            }
                        }
                    }else // we are in most left lane and can not turn left
                    {
                        violate_left = true;
                    }

                    //find the closest car in right lane
                    if (find_lane(car_d) < 3) // if there is any left lane
                    {
                        if (cars_myright_s.size() == 0)
                        {
                            dist_closest_right_front = 999;
                            dist_closest_right_back = 999;
                            vel_closest_right_front = 0;
                        }else
                        {
                            for (int i = 0; i < cars_myright_s.size(); ++i)
                            {
                                double other_myright_s = cars_myright_s[i];
                                double dist2mycar_right = other_myright_s - car_s;
                                if (dist2mycar_right >= 0) // front right
                                {
                                    if (dist2mycar_right < abs(dist_closest_right_front))
                                    {
                                        dist_closest_right_front = dist2mycar_right;
                                        vel_closest_right_front = cars_myright_vel[i];
                                    }
                                }else if (dist2mycar_right < 0) // back right
                                {
                                    if (abs(dist2mycar_right) < abs(dist_closest_right_back))
                                    {
                                        dist_closest_right_back = abs(dist2mycar_right);
                                    }
                                }


                            }
                        }
                    }else // we are in most right lane and can not turn left
                    {
                        violate_right = true;
                    }

                    // debug
//                    cout<<"distance to closest car in left front is:"<< dist_closest_left_front;
//                    cout<<"distance to closest car in left back is:"<< dist_closest_left_back;
//
//                    cout<<"distance to closest car in right front is:"<< dist_closest_right_front;
//                    cout<<"distance to closest car in right back is:"<< dist_closest_right_back;
//

                    // STEP2: calculate cost of actions and select the one with minimum cost

                    double buffer_current = 50;
                    double buffer_lc = 20;
                    double cost_collision = 500;
                    double cost_left_turn = 150;
                    double cost_right_turn = 150;
                    double cost_slow_down = 200;

                    double continue_lane_tc;
                    double slow_down_tc;
                    double left_turn_tc;
                    double right_turn_tc;

                    int decision = 10;
                    double min_cost = 800;
                    vector<double> costs;

                    // calculate costs
                    continue_lane_tc = cost_keep_lane(cars_mylane_s.size(), dist_closest_front, buffer_current, cost_collision);
                    costs.push_back(continue_lane_tc);

                    slow_down_tc = cost_slow_down_inlane(cost_slow_down);
                    costs.push_back(slow_down_tc);

                    left_turn_tc = cost_change_left(dist_closest_left_front, dist_closest_left_back, buffer_lc, cost_collision, cost_left_turn, violate_left);
                    costs.push_back(left_turn_tc);

                    right_turn_tc = cost_change_right(dist_closest_right_front, dist_closest_right_back, buffer_lc, cost_collision, cost_right_turn, violate_right);
                    costs.push_back(right_turn_tc);

                    // select action with minimum cost
                    for (int i = 0; i < costs.size(); ++i)
                    {
                        double cost_tmp = costs[i];
                        if (cost_tmp < min_cost)
                        {
                            min_cost = cost_tmp;
                            decision = i;
                        }
                    }

                    // decision = 0 ; keep lane with max speed
                    //decision = 1; keep lane but slow down
                    // decision = 2; change to left lane
                    // decision = 3 ; change to right lane

                    if (decision == 0) //keep lane with max speed
                    {
                        cout<<"Action: keep lane with max speed"<<endl;
                    }else if(decision == 1)
                    {
                        cout<<"Action: keep lane and slow down"<<endl;
                    }else if(decision == 2)
                    {
                        cout<<"Action: change lane to left"<<endl;
                    }else
                    {
                        cout<<"Action: change lane to right"<<endl;
                    }


                    // STEP3: Once decision has been made,
                    // decide the target speed and lane for that decision

                    if (decision == 0) // keep lane with max speed
                    {
                        target_s_inc = 0.415;
                        if (find_lane(car_d) == 1)
                        {
                            target_d = 2;
                        }else if(find_lane(car_d) == 2)
                        {
                            target_d = 6;
                        }else if(find_lane(car_d) == 3)
                        {
                            target_d = 10;
                        }else
                        {
                            target_d = 6;
                        }
                    }else if (decision == 1) // slow down
                    {

//                        //Stay in current lane but slow down
//                        if (ms2mph(vel_closest_front) > 45)
//                        {
//                            target_s_inc = 0.40;
//                        }
//
//                        else if (ms2mph(vel_closest_front) > 40)
//                        {
//                            target_s_inc = 0.35;
//                        }
//
//                        else if (ms2mph(vel_closest_front) > 35)
//                        {
//                            target_s_inc = 0.30;
//                        }
//
//                        else if (ms2mph(vel_closest_front) > 30)
//                        {
//                            target_s_inc = 0.25;
//                        }
//
//                        else target_s_inc = 0.22;


                        target_s_inc = 0.2;
                        if (dist_closest_front < 20)
                        {
                            target_s_inc -= 0.02;
                        }


                        if (find_lane(car_d) == 1)
                        {
                            target_d = 2;
                        }else if(find_lane(car_d) == 2)
                        {
                            target_d = 6;
                        }else if(find_lane(car_d) == 3)
                        {
                            target_d = 10;
                        }else
                        {
                            target_d = 6;
                        }

                    }else if (decision == 2) // turn left
                    {
                        target_s_inc = 0.415;
                        if (find_lane(car_d) <= 2)
                        {
                            target_d = 2;
                        }else if (find_lane(car_d) == 3)
                        {
                            target_d = 6;
                        }else
                        {
                            target_d = 6;
                        }
                    }else if (decision == 3) // turn right
                    {
                        target_s_inc = 0.415;
                        if (find_lane(car_d) == 1)
                        {
                            target_d = 6;
                        }else if (find_lane(car_d) >= 2)
                        {
                            target_d = 10;
                        }else
                        {
                            target_d = 6;
                        }
                    }else
                    {
                        cout<<"something is qoing wrong!!!"<<endl;
                    }


                    // STEP4: generate jmt for lane change and acceleration/deceleration

                    vector<double> next_x_vals;
                    vector<double> next_y_vals;

                    double pos_x;
                    double pos_y;
                    double pos_s;
                    double pos_d;
                    double angle;
                    double prev_s;
                    double prev_d;
                    double prev_target_s_inc;
                    double prev_target_d;
                    double target_s;

                    double wp_x;
                    double wp_y;
                    double wp_dx;
                    double wp_dy;

                    int prev_size = previous_path_x.size();

                    for (int i = 0; i < prev_size; ++i)
                    {
                        next_x_vals.push_back(previous_path_x[i]);
                        next_y_vals.push_back(previous_path_y[i]);
                    }

                    if(prev_size == 0)
                    {
                        pos_x = car_x;
                        pos_y = car_y;
                        pos_s = car_s;
                        pos_d = car_d;
                        prev_s = car_s;
                        prev_d = car_d;
                        prev_target_s_inc = 0.415;
                        prev_target_d = 6;
                        target_s = 0.415;
                    }else
                    {
                        pos_x = previous_path_x[prev_size-1];
                        pos_y = previous_path_y[prev_size-1];

                        double prev_pos_x = previous_path_x[prev_size-2];
                        double prev_pos_y = previous_path_y[prev_size-2];

                        angle = atan2(pos_y - prev_pos_y , pos_x - prev_pos_x);
                    }

                    // smooth change in lane
                    double d_smoothing_steps = 80;

                    //best jerk minimal trajectories generated by difference between target_d and previous d
                    double delta_d = (target_d - prev_d) / d_smoothing_steps;

                    // smooth acceleration and braking
                    double s_smoothing_steps = 80;
                    double delta_s = (target_s_inc - prev_target_s_inc) / s_smoothing_steps;

                    // debug
//                    cout <<"Target s inc: "<< target_s_inc;
//                    cout <<"\t Previous target s inc: "<< prev_target_s_inc;
//                    cout <<"\t Target s: "<< target_s<<endl;
//
//
//                    cout<<"Target d: "<< target_d;
//                    cout<<"\t End path d: "<< end_path_d;
//                    cout<<"\t Previous d: "<< prev_d;
//                    cout<<"\t Car d: "<< car_d<<endl;


                    for (int i = 0; i < 50 - prev_size; ++i) {
                        double delta_s2 = pos_s - prev_s;

                        prev_s = pos_s;
                        prev_d = pos_d;

                        target_s += min(delta_s, 0.01);
                        prev_target_s_inc += delta_s;

                        // use difference between current s and previous s to slowly increase the speed of the car at the begining
                        pos_s += min(target_s, delta_s2*1.005 + 0.002);
                        pos_s = fmod(pos_s, max_s); // reset s at the end of track

                        if (delta_d >= 0)
                        {
                            pos_d += min(delta_s, 0.02);
                        }else
                        {
                            pos_d += max(delta_d, -0.02);
                        }

                        prev_target_d += delta_d;

                        wp_x = path_spline_x(pos_s);
                        wp_y = path_spline_y(pos_s);
                        wp_dx = path_spline_dx(pos_s);
                        wp_dy = path_spline_dy(pos_s);

                        pos_x = wp_x + pos_d * wp_dx;
                        pos_y = wp_y + pos_d * wp_dy;

                        next_x_vals.push_back(pos_x);
                        next_y_vals.push_back(pos_y);

                    }


                    json msgJson;

                    msgJson["next_x"] = next_x_vals;
                    msgJson["next_y"] = next_y_vals;

                    auto msg = "42[\"control\","+ msgJson.dump()+"]";

                    //this_thread::sleep_for(chrono::milliseconds(1000));
                    ws.send(msg.data(), msg.length(), uWS::OpCode::TEXT);

                }
            } else {
                // Manual driving
                std::string msg = "42[\"manual\",{}]";
                ws.send(msg.data(), msg.length(), uWS::OpCode::TEXT);
            }
        }
    });

    // We don't need this since we're not using HTTP but if it's removed the
    // program
    // doesn't compile :-(
    h.onHttpRequest([](uWS::HttpResponse *res, uWS::HttpRequest req, char *data,
                       size_t, size_t) {
        const std::string s = "<h1>Hello world!</h1>";
        if (req.getUrl().valueLength == 1) {
            res->end(s.data(), s.length());
        } else {
            // i guess this should be done more gracefully?
            res->end(nullptr, 0);
        }
    });

    h.onConnection([&h](uWS::WebSocket<uWS::SERVER> ws, uWS::HttpRequest req) {
        std::cout << "Connected!!!" << std::endl;
    });

    h.onDisconnection([&h](uWS::WebSocket<uWS::SERVER> ws, int code,
                           char *message, size_t length) {
        ws.close();
        std::cout << "Disconnected" << std::endl;
    });

    int port = 4567;
    if (h.listen(port)) {
        std::cout << "Listening to port " << port << std::endl;
    } else {
        std::cerr << "Failed to listen to port" << std::endl;
        return -1;
    }
    h.run();
}
